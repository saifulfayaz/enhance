<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>Color Replacer ¬∑ Perspective Crop</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(145deg, #f0f4f8 0%, #e6ecf3 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 16px;
        }

        .app-container {
            max-width: 1400px;
            width: 100%;
        }

        .main-card {
            background: rgba(255,255,255,0.7);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 32px;
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.25);
            padding: 24px;
            border: 1px solid rgba(255,255,255,0.5);
        }

        .split-layout {
            display: flex;
            flex-wrap: wrap;
            gap: 24px;
        }

        .canvas-section {
            flex: 2;
            min-width: 300px;
        }

        .canvas-wrapper {
            background: #1a1e2c;
            border-radius: 24px;
            padding: 8px;
            box-shadow: 0 20px 30px -10px rgba(0,0,0,0.3);
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
            border-radius: 16px;
            cursor: crosshair;
            background: #fff;
        }

        .canvas-hint {
            font-size: 0.85rem;
            color: #4b5565;
            margin-top: 10px;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
        }

        .hint-icon {
            background: #3b82f6;
            color: white;
            border-radius: 30px;
            padding: 4px 12px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .controls-section {
            flex: 1;
            min-width: 260px;
            background: rgba(255,255,255,0.5);
            border-radius: 28px;
            padding: 20px;
            backdrop-filter: blur(4px);
            box-shadow: 0 10px 20px -5px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.6);
        }

        .dropzone {
            border: 2px dashed #9aa9b9;
            border-radius: 24px;
            padding: 20px 12px;
            text-align: center;
            background: rgba(255,255,255,0.4);
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 20px;
        }

        .dropzone:hover {
            border-color: #3b82f6;
            background: rgba(59,130,246,0.05);
        }

        .dropzone p {
            font-size: 0.9rem;
            color: #2c3e50;
            font-weight: 500;
        }

        .dropzone input {
            display: none;
        }

        .color-panel {
            background: white;
            border-radius: 50px;
            padding: 10px 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.03);
            flex-wrap: wrap;
        }

        .selected-color {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .color-swatch {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .color-text {
            font-family: 'SF Mono', 'Fira Code', monospace;
            font-size: 0.8rem;
            background: #f1f5f9;
            padding: 4px 10px;
            border-radius: 30px;
            color: #1e293b;
        }

        .manual-picker {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-left: auto;
        }

        .manual-picker label {
            font-size: 0.85rem;
            color: #4a5a6e;
        }

        input[type="color"] {
            width: 40px;
            height: 36px;
            border: 1px solid #ccd9e9;
            border-radius: 30px;
            background: white;
            cursor: pointer;
        }

        .tolerance-card {
            background: white;
            border-radius: 24px;
            padding: 16px 18px;
            margin-bottom: 20px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.03);
        }

        .tolerance-header {
            display: flex;
            justify-content: space-between;
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 12px;
            font-size: 0.95rem;
        }

        .tolerance-value {
            background: #3b82f6;
            color: white;
            padding: 2px 12px;
            border-radius: 40px;
            font-size: 0.85rem;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 10px;
            background: #e2e8f0;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            background: white;
            border-radius: 50%;
            border: 2px solid #3b82f6;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-top: -7px;
        }

        .action-grid {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .button-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            flex: 1 1 auto;
            padding: 14px 8px;
            border: none;
            border-radius: 40px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
            box-shadow: 0 8px 16px -8px rgba(0,0,0,0.1);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            border: 1px solid transparent;
        }

        button:active {
            transform: scale(0.97);
        }

        .btn-white {
            background: white;
            color: #1e293b;
            border-color: #cbd5e1;
        }

        .btn-white:hover {
            background: #f8fafc;
        }

        .btn-black {
            background: #0f172a;
            color: white;
        }

        .btn-black:hover {
            background: #1e293b;
        }

        .btn-reset {
            background: #f1f5f9;
            color: #334155;
        }

        .btn-reset:hover {
            background: #e2e8f0;
        }

        .btn-download {
            background: #3b82f6;
            color: white;
        }

        .btn-download:hover {
            background: #2563eb;
        }

        .btn-crop {
            background: #8b5cf6;
            color: white;
        }

        .btn-crop:hover {
            background: #7c3aed;
        }

        .btn-apply {
            background: #10b981;
            color: white;
        }

        .btn-cancel {
            background: #f1f5f9;
            color: #475569;
        }

        .crop-status {
            font-size: 0.8rem;
            color: #8b5cf6;
            font-weight: 500;
            text-align: center;
            margin-top: 8px;
            background: rgba(139,92,246,0.1);
            padding: 6px 12px;
            border-radius: 40px;
        }

        .footer-note {
            margin-top: 16px;
            font-size: 0.75rem;
            color: #64748b;
            text-align: center;
        }

        /* Mobile specific */
        @media (max-width: 640px) {
            body {
                padding: 8px;
            }
            .main-card {
                padding: 16px;
                border-radius: 24px;
            }
            .split-layout {
                gap: 16px;
            }
            .canvas-section {
                min-width: 100%;
            }
            .controls-section {
                min-width: 100%;
                padding: 16px;
            }
            .color-panel {
                padding: 8px 12px;
            }
            .button-row button {
                padding: 12px 6px;
                font-size: 0.85rem;
            }
            .dropzone p {
                font-size: 0.85rem;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="main-card">
            <div class="split-layout">
                <!-- Canvas area -->
                <div class="canvas-section">
                    <div class="canvas-wrapper">
                        <canvas id="canvas"></canvas>
                    </div>
                    <div class="canvas-hint">
                        <span class="hint-icon">‚¨ÜÔ∏è</span> Click image to pick color
                        <span id="cropStatus" class="crop-status" style="margin-left:auto;"></span>
                    </div>
                </div>

                <!-- Controls -->
                <div class="controls-section">
                    <!-- Drop zone -->
                    <div class="dropzone" id="dropzone">
                        <p>üìÅ Drag or click to load image</p>
                        <input type="file" id="upload" accept="image/*">
                    </div>

                    <!-- Color picker row -->
                    <div class="color-panel">
                        <div class="selected-color">
                            <div class="color-swatch" id="colorPreview" style="background:#ccc;"></div>
                            <span class="color-text" id="colorValue">not set</span>
                        </div>
                        <div class="manual-picker">
                            <label for="colorPicker">üé®</label>
                            <input type="color" id="colorPicker" value="#ff0000">
                        </div>
                    </div>

                    <!-- Tolerance slider -->
                    <div class="tolerance-card">
                        <div class="tolerance-header">
                            <span>Tolerance</span>
                            <span class="tolerance-value" id="toleranceValue">20</span>
                        </div>
                        <input type="range" id="tolerance" min="0" max="100" value="20">
                    </div>

                    <!-- Action buttons -->
                    <div class="action-grid">
                        <div class="button-row">
                            <button class="btn-white" id="replaceWhite">‚ö™ White</button>
                            <button class="btn-black" id="replaceBlack">‚ö´ Black</button>
                        </div>
                        <div class="button-row">
                            <button class="btn-reset" id="resetBtn">‚Ü∫ Reset</button>
                            <button class="btn-download" id="downloadBtn">‚¨á Download</button>
                        </div>
                        <div class="button-row">
                            <button class="btn-crop" id="cropBtn">‚úÇÔ∏è Crop</button>
                            <button class="btn-apply" id="applyCropBtn" style="display:none;">‚úî Apply</button>
                            <button class="btn-cancel" id="cancelCropBtn" style="display:none;">‚úñ Cancel</button>
                        </div>
                    </div>
                    <div class="footer-note">live preview ‚Ä¢ corners order: TL, TR, BR, BL</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // (same JavaScript as before, unchanged)
        (function() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const fileInput = document.getElementById('upload');
            const dropzone = document.getElementById('dropzone');
            const colorPreview = document.getElementById('colorPreview');
            const colorValue = document.getElementById('colorValue');
            const colorPicker = document.getElementById('colorPicker');
            const toleranceSlider = document.getElementById('tolerance');
            const toleranceSpan = document.getElementById('toleranceValue');
            const replaceWhiteBtn = document.getElementById('replaceWhite');
            const replaceBlackBtn = document.getElementById('replaceBlack');
            const resetBtn = document.getElementById('resetBtn');
            const downloadBtn = document.getElementById('downloadBtn');
            const cropBtn = document.getElementById('cropBtn');
            const applyCropBtn = document.getElementById('applyCropBtn');
            const cancelCropBtn = document.getElementById('cancelCropBtn');
            const cropStatus = document.getElementById('cropStatus');

            let originalImageData = null;
            let currentImageData = null;
            let targetColor = { r: 255, g: 0, b: 0 };
            let imageLoaded = false;
            let previewFrame = null;

            // Crop state
            let cropMode = false;
            let cropPoints = [];          // array of {x,y} (canvas coordinates)
            const MAX_POINTS = 4;

            // tolerance display
            toleranceSlider.addEventListener('input', () => {
                toleranceSpan.textContent = toleranceSlider.value;
                if (imageLoaded && !cropMode) {
                    if (previewFrame) cancelAnimationFrame(previewFrame);
                    previewFrame = requestAnimationFrame(updatePreview);
                }
            });

            colorPicker.addEventListener('input', (e) => {
                targetColor = hexToRgb(e.target.value);
                updateColorDisplay();
                if (imageLoaded && !cropMode) {
                    if (previewFrame) cancelAnimationFrame(previewFrame);
                    previewFrame = requestAnimationFrame(updatePreview);
                }
            });

            function hexToRgb(hex) {
                const bigint = parseInt(hex.slice(1), 16);
                return { r: (bigint >> 16) & 255, g: (bigint >> 8) & 255, b: bigint & 255 };
            }

            function rgbToHex(r, g, b) {
                return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            }

            function updateColorDisplay() {
                colorPreview.style.backgroundColor = `rgb(${targetColor.r}, ${targetColor.g}, ${targetColor.b})`;
                colorValue.textContent = `rgb(${targetColor.r}, ${targetColor.g}, ${targetColor.b})`;
            }

            function loadImageFromFile(file) {
                if (!file.type.startsWith('image/')) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);
                        originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        currentImageData = new ImageData(new Uint8ClampedArray(originalImageData.data), canvas.width, canvas.height);
                        imageLoaded = true;
                        exitCropMode(); // ensure crop mode off
                        ctx.putImageData(currentImageData, 0, 0);
                        if (previewFrame) cancelAnimationFrame(previewFrame);
                        previewFrame = requestAnimationFrame(updatePreview);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) loadImageFromFile(file);
            });

            dropzone.addEventListener('click', () => fileInput.click());
            dropzone.addEventListener('dragover', (e) => e.preventDefault());
            dropzone.addEventListener('drop', (e) => {
                e.preventDefault();
                const file = e.dataTransfer.files[0];
                if (file) loadImageFromFile(file);
            });

            // Canvas click handler ‚Äì depends on mode
            canvas.addEventListener('click', (e) => {
                if (!imageLoaded) return;

                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = Math.floor((e.clientX - rect.left) * scaleX);
                const y = Math.floor((e.clientY - rect.top) * scaleY);
                if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) return;

                if (cropMode) {
                    // Add crop point (max 4)
                    if (cropPoints.length < MAX_POINTS) {
                        cropPoints.push({ x, y });
                        redrawCropOverlay();
                    }
                    if (cropPoints.length === MAX_POINTS) {
                        applyCropBtn.style.display = 'block';
                        cancelCropBtn.style.display = 'block';
                        cropStatus.textContent = '‚úÖ 4 points set. Apply crop.';
                    } else {
                        cropStatus.textContent = `üìç Point ${cropPoints.length}/4 selected (order: TL, TR, BR, BL)`;
                    }
                } else {
                    // Normal color picking from currentImageData
                    const index = (y * canvas.width + x) * 4;
                    const r = currentImageData.data[index];
                    const g = currentImageData.data[index + 1];
                    const b = currentImageData.data[index + 2];
                    targetColor = { r, g, b };
                    colorPicker.value = rgbToHex(r, g, b);
                    updateColorDisplay();
                    if (previewFrame) cancelAnimationFrame(previewFrame);
                    previewFrame = requestAnimationFrame(updatePreview);
                }
            });

            function redrawCropOverlay() {
                // Draw the current image + overlay of points and lines
                ctx.putImageData(currentImageData, 0, 0);
                if (cropPoints.length === 0) return;

                // Draw points with numbers
                for (let i = 0; i < cropPoints.length; i++) {
                    const p = cropPoints[i];
                    // Draw circle
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 8, 0, 2 * Math.PI);
                    ctx.fillStyle = '#8b5cf6';
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Draw number
                    ctx.font = 'bold 14px monospace';
                    ctx.fillStyle = 'white';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(i + 1, p.x, p.y);
                }

                // Draw lines connecting in order
                if (cropPoints.length > 1) {
                    ctx.beginPath();
                    ctx.strokeStyle = '#8b5cf6';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 3]);
                    ctx.moveTo(cropPoints[0].x, cropPoints[0].y);
                    for (let i = 1; i < cropPoints.length; i++) {
                        ctx.lineTo(cropPoints[i].x, cropPoints[i].y);
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                // If we have 4 points, close the quadrilateral
                if (cropPoints.length === 4) {
                    ctx.beginPath();
                    ctx.strokeStyle = '#f97316';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([]);
                    ctx.moveTo(cropPoints[0].x, cropPoints[0].y);
                    ctx.lineTo(cropPoints[1].x, cropPoints[1].y);
                    ctx.lineTo(cropPoints[2].x, cropPoints[2].y);
                    ctx.lineTo(cropPoints[3].x, cropPoints[3].y);
                    ctx.lineTo(cropPoints[0].x, cropPoints[0].y);
                    ctx.stroke();
                }
            }

            function exitCropMode() {
                cropMode = false;
                cropPoints = [];
                applyCropBtn.style.display = 'none';
                cancelCropBtn.style.display = 'none';
                cropStatus.textContent = '';
                // redraw normal view
                ctx.putImageData(currentImageData, 0, 0);
                if (previewFrame) cancelAnimationFrame(previewFrame);
                previewFrame = requestAnimationFrame(updatePreview);
            }

            cropBtn.addEventListener('click', () => {
                if (!imageLoaded) {
                    alert('Load an image first.');
                    return;
                }
                // Enter crop mode
                cropMode = true;
                cropPoints = [];
                applyCropBtn.style.display = 'none';
                cancelCropBtn.style.display = 'block';
                cropStatus.textContent = 'Click 4 corners in order (TL, TR, BR, BL)';
                // Clear any preview overlay and just show current image
                ctx.putImageData(currentImageData, 0, 0);
            });

            cancelCropBtn.addEventListener('click', () => {
                exitCropMode();
            });

            applyCropBtn.addEventListener('click', () => {
                if (cropPoints.length !== 4) return;

                // Use points exactly in the order they were clicked
                const srcPoints = cropPoints.map(p => ({ x: p.x, y: p.y }));

                // Determine output size based on edge lengths
                const dist = (p1, p2) => Math.hypot(p1.x - p2.x, p1.y - p2.y);
                const topWidth = dist(srcPoints[0], srcPoints[1]);
                const bottomWidth = dist(srcPoints[3], srcPoints[2]);
                const leftHeight = dist(srcPoints[0], srcPoints[3]);
                const rightHeight = dist(srcPoints[1], srcPoints[2]);
                const dstWidth = Math.round(Math.max(topWidth, bottomWidth));
                const dstHeight = Math.round(Math.max(leftHeight, rightHeight));

                // Perform warp ‚Äì mapping destination to source
                const dstImageData = perspectiveWarp(currentImageData, srcPoints, dstWidth, dstHeight);

                // Update image data
                originalImageData = dstImageData;
                currentImageData = new ImageData(new Uint8ClampedArray(dstImageData.data), dstWidth, dstHeight);
                canvas.width = dstWidth;
                canvas.height = dstHeight;
                ctx.putImageData(currentImageData, 0, 0);

                exitCropMode();
            });

            // Perspective warp using homography (DLT)
            function perspectiveWarp(srcImageData, srcQuad, dstWidth, dstHeight) {
                const srcW = srcImageData.width;
                const srcH = srcImageData.height;
                const srcData = srcImageData.data;

                // Destination corners: top-left, top-right, bottom-right, bottom-left
                const dstQuad = [
                    { x: 0, y: 0 },
                    { x: dstWidth - 1, y: 0 },
                    { x: dstWidth - 1, y: dstHeight - 1 },
                    { x: 0, y: dstHeight - 1 }
                ];

                // Compute homography that maps destination to source
                const H = computeHomography(dstQuad, srcQuad);

                // Create destination ImageData
                const dstImageData = new ImageData(dstWidth, dstHeight);
                const dstData = dstImageData.data;

                // For each destination pixel, find source pixel
                for (let dy = 0; dy < dstHeight; dy++) {
                    for (let dx = 0; dx < dstWidth; dx++) {
                        const denominator = H[6] * dx + H[7] * dy + H[8];
                        const sx = (H[0] * dx + H[1] * dy + H[2]) / denominator;
                        const sy = (H[3] * dx + H[4] * dy + H[5]) / denominator;

                        const ix = Math.floor(sx);
                        const iy = Math.floor(sy);
                        const fx = sx - ix;
                        const fy = sy - iy;

                        if (ix >= 0 && ix < srcW - 1 && iy >= 0 && iy < srcH - 1) {
                            const i00 = (iy * srcW + ix) * 4;
                            const i10 = (iy * srcW + ix + 1) * 4;
                            const i01 = ((iy + 1) * srcW + ix) * 4;
                            const i11 = ((iy + 1) * srcW + ix + 1) * 4;

                            for (let c = 0; c < 4; c++) {
                                const val = 
                                    (1 - fx) * (1 - fy) * srcData[i00 + c] +
                                    fx * (1 - fy) * srcData[i10 + c] +
                                    (1 - fx) * fy * srcData[i01 + c] +
                                    fx * fy * srcData[i11 + c];
                                dstData[(dy * dstWidth + dx) * 4 + c] = Math.round(val);
                            }
                        } else {
                            dstData[(dy * dstWidth + dx) * 4 + 3] = 0; // transparent
                        }
                    }
                }
                return dstImageData;
            }

            // Compute homography matrix mapping src points to dst points
            function computeHomography(src, dst) {
                const n = src.length;
                const A = [];
                for (let i = 0; i < n; i++) {
                    const x = src[i].x;
                    const y = src[i].y;
                    const u = dst[i].x;
                    const v = dst[i].y;
                    A.push([-x, -y, -1, 0, 0, 0, x*u, y*u, u]);
                    A.push([0, 0, 0, -x, -y, -1, x*v, y*v, v]);
                }
                const B = [];
                const M = [];
                for (let i = 0; i < 8; i++) {
                    M.push(A[i].slice(0, 8));
                    B.push(-A[i][8]);
                }
                const h = solveLinear(M, B);
                h.push(1);
                return h;
            }

            // Gaussian elimination for 8x8 system
            function solveLinear(M, B) {
                const n = M.length;
                for (let i = 0; i < n; i++) {
                    M[i].push(B[i]);
                }
                for (let i = 0; i < n; i++) {
                    let maxRow = i;
                    for (let k = i+1; k < n; k++) {
                        if (Math.abs(M[k][i]) > Math.abs(M[maxRow][i])) maxRow = k;
                    }
                    [M[i], M[maxRow]] = [M[maxRow], M[i]];
                    const pivot = M[i][i];
                    if (Math.abs(pivot) < 1e-12) continue;
                    for (let j = i; j <= n; j++) {
                        M[i][j] /= pivot;
                    }
                    for (let k = i+1; k < n; k++) {
                        const factor = M[k][i];
                        for (let j = i; j <= n; j++) {
                            M[k][j] -= factor * M[i][j];
                        }
                    }
                }
                const x = new Array(n);
                for (let i = n-1; i >= 0; i--) {
                    x[i] = M[i][n];
                    for (let j = i+1; j < n; j++) {
                        x[i] -= M[i][j] * x[j];
                    }
                }
                return x;
            }

            // Live preview (only when not in crop mode)
            function updatePreview() {
                if (!imageLoaded || cropMode) return;
                const previewData = new ImageData(new Uint8ClampedArray(currentImageData.data), canvas.width, canvas.height);
                const data = previewData.data;
                const target = targetColor;
                const tolerance = parseInt(toleranceSlider.value, 10);
                const threshold = tolerance * 3;

                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i], g = data[i+1], b = data[i+2];
                    const diff = Math.abs(r - target.r) + Math.abs(g - target.g) + Math.abs(b - target.b);
                    if (diff <= threshold) {
                        data[i] = Math.min(255, r + 80);
                        data[i+1] = Math.max(0, g - 40);
                        data[i+2] = Math.max(0, b - 40);
                    }
                }
                ctx.putImageData(previewData, 0, 0);
            }

            function replaceWith(newR, newG, newB) {
                if (!imageLoaded) return;
                const data = currentImageData.data;
                const target = targetColor;
                const tolerance = parseInt(toleranceSlider.value, 10);
                const threshold = tolerance * 3;

                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i], g = data[i+1], b = data[i+2];
                    const diff = Math.abs(r - target.r) + Math.abs(g - target.g) + Math.abs(b - target.b);
                    if (diff <= threshold) {
                        data[i] = newR;
                        data[i+1] = newG;
                        data[i+2] = newB;
                    }
                }
                ctx.putImageData(currentImageData, 0, 0);
                if (!cropMode) {
                    if (previewFrame) cancelAnimationFrame(previewFrame);
                    previewFrame = requestAnimationFrame(updatePreview);
                }
            }

            replaceWhiteBtn.addEventListener('click', () => replaceWith(255, 255, 255));
            replaceBlackBtn.addEventListener('click', () => replaceWith(0, 0, 0));

            resetBtn.addEventListener('click', () => {
                if (!imageLoaded) return;
                currentImageData.data.set(originalImageData.data);
                ctx.putImageData(currentImageData, 0, 0);
                if (!cropMode) {
                    if (previewFrame) cancelAnimationFrame(previewFrame);
                    previewFrame = requestAnimationFrame(updatePreview);
                }
            });

            downloadBtn.addEventListener('click', () => {
                if (!imageLoaded) return;
                const link = document.createElement('a');
                link.download = 'image.png';
                canvas.toBlob((blob) => {
                    link.href = URL.createObjectURL(blob);
                    link.click();
                    URL.revokeObjectURL(link.href);
                });
            });

            updateColorDisplay();
        })();
    </script>
</body>
</html>
